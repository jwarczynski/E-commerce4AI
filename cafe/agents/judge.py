from typing import Any, Dict

from smolagents import Tool

from cafe.core.snowflake_client import SnowflakeClient
from cafe.strategies.validation import ExecutionValidation, SemanticValidation, SyntaxValidation, ValidationStrategy
from .base_agent import BaseAgent
from ..utils.logger import setup_logger


class RuleBasedJudge(BaseAgent):
    """Agent that validates SQL queries for correctness and usefulness."""

    def __init__(self, snowflake_client: SnowflakeClient, validation_strategies: list[ValidationStrategy] = None):
        super().__init__()
        self.snowflake_client = snowflake_client
        self.validation_strategies = validation_strategies or [
            SyntaxValidation(),
            ExecutionValidation(self.snowflake_client),
            SemanticValidation()
        ]

    def validate(self, sql: str, prompt: str, semantic_model: str) -> Dict[str, Any]:
        return self.run(sql, prompt, semantic_model)

    def run(self, sql: str, prompt: str, semantic_model: str) -> Dict[str, Any]:
        """Validate a SQL query using multiple strategies."""
        query_result = self.snowflake_client.execute_query(sql)

        results = {}
        for strategy in self.validation_strategies:
            is_valid, message = strategy.validate(sql, prompt, semantic_model, query_result)
            results[strategy.__class__.__name__] = {"valid": is_valid, "message": message}
            if not is_valid:
                self.logger.error(f"Validation failed: {message}")
                return results
        self.logger.info("All validations passed")
        return results


class JudgeAgent(Tool):
    """Agent that validates SQL queries generated by Cortex Analyst."""

    name = "sql_queries_verifier"

    description = """
    This tool verifies the SQL queries generated by the Cortex Analyst. It first execute the query and based on the result and sql itself assess the quality of the query.
    It takes into consideration business question, semantic model and the goal of extending the database for future engineering tasks.
    It returns its verdict and explanation.
    """
    inputs = {
        "sql_query": {
            "description": "The SQL query to be validated.",
            "type": "string"
        },
        "business_question": {
            "description": "The business question related to the SQL query.",
            "type": "string"
        },
        "semantic_model": {
            "type": "string",
            "description": """
            The semantic model related to the SQL query. It is used to assess the quality of the query.
            It should be in YAML format and contain information about the database schema, tables, and columns.
            """
        }
    }
    output_type = "string"

    def __init__(self, snowflake_client: SnowflakeClient):
        super().__init__()
        self.logger = setup_logger(self.__class__.__name__)
        self.snowflake_client = snowflake_client
        self.host = snowflake_client.config["host"]  # Access host from the client config

    def forward(self, sql_query: str, business_question: str, semantic_model: str) -> str:
        return self.run(sql_query, business_question, semantic_model)

    def run(self, sql_query: str, business_question: str, semantic_model: str) -> str:
        """Validates the SQL query by executing it and assessing its usefulness."""
        try:
            sql_result = self._execute_query(sql_query)
        except Exception as e:
            return str(e)
        if sql_result is None:
            self.logger.warning(f"Generated query is not executable: {sql_query}")
            return "Query execution failed. Please check the SQL syntax."

        verdict = self._assess_usefulness(sql_query, business_question, sql_result=sql_result, semantic_model=semantic_model)
        return verdict

    def _execute_query(self, sql_query: str) -> dict[str, Any] | None:
        """Executes the SQL query against Snowflake to verify its validity."""
        try:
            result = self.snowflake_client.execute_query(sql_query)
            self.logger.info("Query executed successfully.")
            return result
        except Exception as e:
            self.logger.error(f"Error executing query: {e}")
            raise e

    def _assess_usefulness(
            self,
            sql_query: str,
            business_question: str,
            sql_result: dict[str, Any],
            semantic_model: str,
            use_heuristic=False
    ) -> str:
        """Assesses the usefulness of the query based on its structure and results."""

        evaluation_prompt = f"""
You are a helpful agent that evaluates the usefulness of a SQL query:
{sql_query}
---
and its shortened result:
columns: {sql_result["columns"]}
frist 10 rows: {sql_result["data"][:10]}
---
in the context of the following business question and semantic model.
Business question: {business_question}
---
Semantic model: {semantic_model}
---
Considering the goal of extending the database for future engineering tasks,
does this query seem likely to contribute meaningfully?
Explain your reasoning."""

        response = self._call_snowflake_llm(evaluation_prompt)
        self.logger.debug(f"Judge LLM response: {response}")
        response_content = response.get("choices", [{}])[0].get("message", {}).get("content", "")
        self.logger.debug(f"Response content: {response_content}")
        return response_content

    def _call_snowflake_llm(self, prompt: str) -> Dict[str, Any]:
        """Calls the Snowflake LLM API (inference:complete endpoint)."""
        data = {
            "model": "claude-3-5-sonnet",  # Or another suitable model
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 500,  # Adjust as needed
            "top_p": 0.9,
            "temperature": 0.2,
            "stream": False
        }
        return self.snowflake_client.call_cortex_llm(data)

    def _heuristic_analysis(self, sql_query: str, original_prompt: str) -> bool:
        """Perform a simple heuristic analysis of the SQL query."""
        if "ADD COLUMN" in sql_query.upper() or "CREATE TABLE" in sql_query.upper():
            self.logger.info("Query seems to aim at extending the schema.")
            # Further checks could be added here, e.g., looking at the column names
            return True
        else:
            self.logger.warning("Query does not seem to directly extend the schema.")
            return False
