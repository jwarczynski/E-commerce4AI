import time
from pathlib import Path

from smolagents import tool

from cafe import semantic_model_manager, snowflake_client


@tool
def text_output_tool(text: str) -> str:
    """
    A tool that outputs the text content of the input. Usefull when user ask about the textual output e.g. code, sql query, etc.
    For example when user asks about modifying sql query, this tool will be used to output the sql query.

    Exapmle:
        ```python
        text_output_tool("text": "SELECT * FROM table")
        ```

    Args:
        text: The text content to output.
    Returns:
        str: The text content of the input.
    """
    return text


@tool
def ask_for_sql(business_question: str, semantic_model_path: str) -> str:
    """
    Call the Cortex Analyst API to generate SQL queries aiming to answer the business question based on the semantic model which describes the tables and columns.
    Args:
        business_question (str): The business question to ask for.
        semantic_model_path (str): The path to semantic model file.
    Returns:
        str: The generated SQL query if successful else descriptive message with casue of failure.
    Raises:
        ValueError: If no SQL query is generated by Cortex Analyst.
    """
    semantic_model = semantic_model_manager.load_yaml(semantic_model_path)
    response = snowflake_client.call_cortex_analyst(
        {
            "messages": [{"role": "user", "content": [{"type": "text", "text": business_question}]}],
            "semantic_model": semantic_model,
        }
    )
    for item in response["message"]["content"]:
        if item["type"] == "sql":
            return item["statement"]

        # If no SQL is found, concatenate text and suggestions
    result = []
    for item in response["message"]["content"]:
        if item["type"] == "text":
            result.append(item["text"])
        elif item["type"] == "suggestions":
            suggestions = item.get("suggestions", [])
            if suggestions:
                result.append("\nSuggestions:\n" + "\n".join(f"- {sug}" for sug in suggestions))

    if result:
        return "\n".join(result)
    raise ValueError("No content generated by Cortex Analyst")


@tool
def save_semantic_model(semantic_model: str, base_semantic_model_path: str) -> str:
    """
    Save the generated semantic model to a file and add it to the semantic model graph.
    Args:
        semantic_model (str): The semantic model to save.
        base_semantic_model_path (str | Path): The path to the base semantic model file.
    Returns:
        str: The path to the saved semantic model file.
    Throws:
        ValueError: If the semantic model is not valid.
    """
    new_semantic_model_path = Path.cwd().parent / "semantic_models" / f"revenue_timeseries{time.time()}.yaml"

    with open(new_semantic_model_path, "w") as f:
        f.write(semantic_model)

    semantic_model_manager.add_new_semantic_model(semantic_model, new_semantic_model_path, base_semantic_model_path)
    return str(new_semantic_model_path)


@tool
def update_verified_queries(sql_query: str, business_question: str, query_name: str, semantic_model_path: str) -> str:
    """
    Update the verified queries section of the semantic model with the new SQL query and business question.
    Args:
        sql_query (str): The SQL query to update the verified queries section with.
        business_question (str): The business question relveant to the sql query.
        query_name (str): The name of the query. It's short description of the query.
        semantic_model_path (str | Path): The path to the semantic model file which should be updated.
    Returns:
        str: The path to the updated semantic model file.
    """
    semantic_model_manager.update_verified_queries(
        file_path=semantic_model_path, query_name=query_name, question=business_question, sql=sql_query
    )
    return str(semantic_model_path)


@tool
def execute_sql_query(sql_query: str) -> dict:
    """
    Execute the SQL query and return the result.
    Args:
        sql_query (str): The SQL query to execute.
    Returns:
        dict[str, Any]: The result of the SQL query. The result contains 'columns' and 'data' keys.
        'columns' is a list of column names and 'data' is a list of forst 5 rows, where each row is a tuple of values.
    """
    sql_result = snowflake_client.execute_query(sql_query)
    data = sql_result["data"]
    columns = sql_result["columns"]

    return {
        "columns": columns,
        "data": data[:5]
    }