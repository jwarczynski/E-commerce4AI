import time
from pathlib import Path

from smolagents import tool

from cafe import semantic_model_manager, snowflake_client


@tool
def text_output_tool(text: str) -> str:
    """
    A tool that outputs the text content of the input. Usefull when user ask about the textual output e.g. code, sql query, etc.
    For example when user asks about modifying sql query, this tool will be used to output the sql query.

    Exapmle:
        ```python
        text_output_tool("text": "SELECT * FROM table")
        ```

    Args:
        text: The text content to output.
    Returns:
        str: The text content of the input.
    """
    return text


@tool
def ask_for_sql(business_question: str, semantic_model_path: str) -> str:
    """
    Call the Cortex Analyst API to generate SQL queries aiming to answer the business question based on the semantic model which describes the tables and columns.
    Args:
        business_question (str): The business question to ask for.
        semantic_model_path (str): The path to semantic model file.
    Returns:
        str: The generated SQL query.
    Raises:
        ValueError: If no SQL is generated by Cortex Analyst.
    """
    # global snowflake_client
    # global semantic_model_manager
    semantic_model = semantic_model_manager.load_yaml(semantic_model_path)
    response = snowflake_client.call_cortex_analyst(
        {
            "messages": [{"role": "user", "content": [{"type": "text", "text": business_question}]}],
            "semantic_model": semantic_model,
        }
    )
    for item in response["message"]["content"]:
        if item["type"] == "sql":
            return item["statement"]
    raise ValueError("No SQL generated by Cortex Analyst")


@tool
def save_semantic_model(semantic_model: str, base_semantic_model_path: str) -> str:
    """
    Save the generated semantic model to a file and add it to the semantic model graph.
    Args:
        semantic_model (str): The semantic model to save.
        base_semantic_model_path (str | Path): The path to the base semantic model file.
    Returns:
        str: The path to the saved semantic model file.
    Throws:
        ValueError: If the semantic model is not valid.
    """
    # global semantic_model_manager
    new_semantic_model_path = Path.cwd().parent / "semantic_models" / f"revenue_timeseries{time.time()}.yaml"

    with open(new_semantic_model_path, "w") as f:
        f.write(semantic_model)

    # Add the new semantic model to the graph
    semantic_model_manager.add_new_semantic_model(semantic_model, new_semantic_model_path, base_semantic_model_path)
    return str(new_semantic_model_path)


@tool
def update_verified_queries(sql_query: str, business_question: str, query_name: str, semantic_model_path: str) -> str:
    """
    Update the verified queries section of the semantic model with the new SQL query and business question.
    Args:
        sql_query (str): The SQL query to update the verified queries section with.
        business_question (str): The business question relveant to the sql query.
        query_name (str): The name of the query. It's short description of the query.
        semantic_model_path (str | Path): The path to the semantic model file which should be updated.
    Returns:
        str: The path to the updated semantic model file.
    """
    # global semantic_model_manager
    semantic_model_manager.update_verified_queries(
        file_path=semantic_model_path, query_name=query_name, question=business_question, sql=sql_query
    )
    return str(semantic_model_path)
